<!DOCTYPE html>
<html>
<head>
    <script src="js/phaser.min.js"></script>
    <script src="js/planck.js"></script>
</head>
<body>

    <script>

      // to open the server with python
      // python -m http.server 8080
      // http://localhost:8080/

      var gameWidth=1000
      var gameHeight=600
      var worldScaleParam=30;

      let game;
      window.onload = function() {
          let gameConfig = {
              type: Phaser.AUTO,
              width: gameWidth,
              height: gameHeight,
              scene: playGame
          }
          game = new Phaser.Game(gameConfig);
          window.focus();
      }

      class playGame extends Phaser.Scene{
          constructor(){
              super("PlayGame");
          }

          preload ()
          {
            this.load.image('sky', 'assets/images/sky.png');
            this.load.image('ground', 'assets/images/platform.png');
            this.load.image('cannon_head', 'assets/images/cannon_head.png');
            this.load.image('cannon_body', 'assets/images/cannon_body.png');
          }

          create ()
          {
            /////// camera /////
            this.cameras.main.setBounds(0, 0, gameWidth*2, gameHeight);
            var cam = this.cameras.main;
            cam.setZoom(1); //<1 => zoom out
            /////// end camera /////

            /////// sky ////////////////
            var skyWidth=this.textures.get('sky').source[0].width;
            this.add.image(0, 0, 'sky').setOrigin(0);
            this.add.image(skyWidth, 0, 'sky').setOrigin(0);
            this.add.image(2*skyWidth, 0, 'sky').setOrigin(0);
            /////// end sky ////////////////

            //////// planck.js box2d /////////////
            // Box2D works with meters. We need to convert meters to pixels.
            // let's say 30 pixels = 1 meter.
            this.worldScale = worldScaleParam;

            // world gravity, as a Vec2 object. It's just a x, y vector (x=gravity horizontal, y gravity vertical)
            let gravity = planck.Vec2(0, 3);
            // this is how we create a Box2D world
            this.world = planck.World(gravity);

            //ground
            var groundHeight=this.textures.get('ground').source[0].height;
            var groundWidth=this.textures.get('ground').source[0].width;
            this.createGround(0, game.config.height - groundHeight, groundWidth, groundHeight, false);
            this.createGround(groundWidth, game.config.height - groundHeight, groundWidth, groundHeight, false);
            this.createGround(2*groundWidth, game.config.height - groundHeight, groundWidth, groundHeight, false);

            //cannon
            var cannonHead = this.add.image(100, game.config.height - groundHeight-100, 'cannon_head').setDepth(1);
            var cannon = this.add.image(100, game.config.height - groundHeight-50, 'cannon_body').setDepth(1);

            //cursor
            var pointer = this.input.activePointer;
            var gfx2 = this.add.graphics().setDefaultStyles({ lineStyle: { width: 10, color: 0xffdd00, alpha: 0.5 } });
            var angle = 0;
            var launchVelocity;

            this.input.on('pointermove', function (pointer) {
                if (pointer.isDown & pointer.y>300 & pointer.x<200) {
                  launchVelocity = this.getLaunchVelocity(cannon,pointer);
                  var lastPos = null;

                  gfx2.clear();
                  for (var i = 0; i < 1000; i += 6)
                  {
                      var trajectoryPoint = this.getTrajectoryPoint(cannon.x, cannon.y - 50, launchVelocity.x, launchVelocity.y, i);

                      if (lastPos && i % 12 == 0)
                      {
                          this.line(gfx2,lastPos.x, lastPos.y, trajectoryPoint.x, trajectoryPoint.y);
                      }

                      lastPos = trajectoryPoint;
                  }
                  var trajectoryPoint = this.getTrajectoryPoint(cannon.x, cannon.y - 50, launchVelocity.x, launchVelocity.y, 30);
                  var trajectoryPoint2 = this.getTrajectoryPoint(cannon.x, cannon.y - 50, launchVelocity.x, launchVelocity.y, 1);
                  //angle = Phaser.Math.Angle.BetweenPoints(cannon, pointer);
                  angle = Phaser.Math.Angle.BetweenPoints(trajectoryPoint2, trajectoryPoint);
                  //angle=Math.max(angle,-1);
                  //angle=Math.min(angle,.5);
                  cannonHead.rotation = angle;
                  //Phaser.Geom.Line.SetToAngle(line, cannon.x, cannon.y - 50, angle, 128);
                  //gfx.clear().strokeLineShape(line);

                }
                else{
                  if (!pointer.isDown) return;
                  this.cameras.main.stopFollow();
                  cam.scrollX -= (pointer.x - pointer.prevPosition.x) / cam.zoom;
                }
            }, this);

          }

          update ()
          {
            this.world.step(1 / worldScaleParam);

            // crearForces  method should be added at the end on each step
            this.world.clearForces();

            // iterate through all bodies
            for (let b = this.world.getBodyList(); b; b = b.getNext()){
                //console.log(b);

                // get body position
                let bodyPosition = b.getPosition();

                // get body angle, in radians
                let bodyAngle = b.getAngle();

                // get body user data, the graphics object
                let userData = b.getUserData();

                // adjust graphic object position and rotation
                userData.x = bodyPosition.x * this.worldScale;
                userData.y = bodyPosition.y * this.worldScale;
                userData.rotation = bodyAngle;
            }


          }

          createBox(posX, posY, width, height, isDynamic){
              let box = this.world.createBody();
              if(isDynamic){
                  box.setDynamic();
              }
              box.createFixture(planck.Box(width / 2 / this.worldScale, height / 2 / this.worldScale));
              box.setPosition(planck.Vec2(posX / this.worldScale, posY / this.worldScale));
              box.setMassData({
                  mass: 1,
                  center: planck.Vec2(),
                  I: 1
              });
              return box;
            }

          createGround(posX, posY, width, height, isDynamic){
              let box = this.createBox(posX, posY, width, height, isDynamic);
              let userData = this.add.image(0, 0, 'ground').setOrigin(0);

              box.setUserData(userData);
          }


      };
    </script>

</body>
</html>
