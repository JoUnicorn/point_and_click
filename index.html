<!DOCTYPE html>
<html>
<head>
    <script src="js/phaser.min.js"></script>
    <script src="js/planck.js"></script>
</head>
<body>

    <script>

      // to open the server with python
      // python -m http.server 8080
      // http://localhost:8080/

      var gameWidth=800
      var gameHeight=600

      let game;
      window.onload = function() {
          let gameConfig = {
              type: Phaser.AUTO,
              width: gameWidth,
              height: gameHeight,
              scene: playGame
          }
          game = new Phaser.Game(gameConfig);
          window.focus();
      }

      class playGame extends Phaser.Scene{
          constructor(){
              super("PlayGame");
          }

          preload ()
          {
            this.load.image('sky', 'assets/images/sky.png');
            this.load.image('ground', 'assets/images/platform.png');
            this.load.image('star', 'assets/images/star.png');
            this.load.image('bomb', 'assets/images/bomb.png');
            this.load.spritesheet('dude',
                'assets/images/dude.png',
                { frameWidth: 32, frameHeight: 48 }
            );

            this.load.image('cannon_head', 'assets/images/cannon_head.png');
            this.load.image('cannon_body', 'assets/images/cannon_body.png');
          }

          create ()
          {
            /*
            var graphics = this.add.graphics();
            var squareWidth=gameWidth/4
            var squareHeight=gameHeight/4

            graphics.fillStyle(0xffffff, 1);
            graphics.fillRect(2*squareWidth, gameHeight-squareHeight, squareWidth, squareHeight);
            graphics.lineStyle(5, 0xFFF0FF, 1.0);
            graphics.fillRect(squareWidth, gameHeight-squareHeight, squareWidth, squareHeight);
            graphics.strokeRect(squareWidth, gameHeight-squareHeight, squareWidth, squareHeight);
            graphics.lineStyle(5, 0xFF00FF, 1.0);
            graphics.fillRect(0, gameHeight-squareHeight, squareWidth, squareHeight);
            graphics.strokeRect(0, gameHeight-squareHeight, squareWidth, squareHeight);
            */

            ////////////////planck///////////////
            // Box2D works with meters. We need to convert meters to pixels.
            // let's say 30 pixels = 1 meter.
            this.worldScale = 30;

            // world gravity, as a Vec2 object. It's just a x, y vector
            let gravity = planck.Vec2(0, 3);

            // this is how we create a Box2D world
            this.world = planck.World(gravity);

            // createBox is a method I wrote to create a box, see how it works at line 55
            this.createBox(game.config.width / 2, game.config.height - 20, game.config.width, 40, false);

            // the rest of the script just creates a random box each 500ms, then restarts after 100 iterations
            this.tick = 0;
            this.time.addEvent({
                delay: 500,
                callbackScope: this,
                callback: function(){
                    this.createBox(Phaser.Math.Between(100, game.config.width - 100), -100, Phaser.Math.Between(20, 80), Phaser.Math.Between(20, 80), true);
                    this.tick ++;
                    if(this.tick == 100){
                        this.scene.start("PlayGame");
                    }
                },
                loop: true
            });
            ////////////////end of planck///////////////



            this.cameras.main.setBounds(0, 0, gameWidth*2, gameHeight);
            this.physics.world.setBounds(0, 0, gameWidth*2, gameHeight);

            /////// sky ////////////////
            this.add.image(0, 0, 'sky').setOrigin(0);
            this.add.image(gameWidth, 0, 'sky').setOrigin(0);
            /////// end sky ////////////////

            /////// platform ////////////////
            platforms = this.physics.add.staticGroup();

            platforms.create(0, 536, 'ground').setOrigin(0).setScale(2).refreshBody();
            platforms.create(800, 536, 'ground').setOrigin(0).setScale(2).refreshBody();

            //platforms.create(600, 400, 'ground');
            platforms.create(50, 250, 'ground');
            //platforms.create(750, 220, 'ground');
            platforms.create(1300, 150, 'ground').setOrigin(0).setRotation(Phaser.Math.DegToRad(90)).refreshBody();
            /////// end platform ////////////////

            /////// canon ////////////////
            var cannonHead = this.add.image(130, 416, 'cannon_head').setDepth(1);
            var cannon = this.add.image(130, 464, 'cannon_body').setDepth(1);
            var gfx = this.add.graphics().setDefaultStyles({ lineStyle: { width: 10, color: 0xffdd00, alpha: 0.5 } });
            var line = new Phaser.Geom.Line();
            var angle = 0;
            //const text = this.add.text(350, 270, '', { font: '16px Courier', fill: '#00ff00' });
            /////// end canon ////////////////

            /////// bullets ////////////////
            bullets = this.physics.add.group({
              key: 'dude',
              frame: [0],
              frameQuantity: 1,
              active: false,
              visible: false,
              repeat: 3
            });
            //console.log(bullets);
            //console.log(bullets.countActive(true));
            bullets.children.iterate(function (child) {
                child.setBounce(0.1);
                child.setCollideWorldBounds(true);
                child.disableBody(true, true);
            });

            this.physics.add.collider(bullets, platforms);
            /////// bullets ////////////////

            /////// animation ////////////////
            this.anims.create({
                key: 'left',
                frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
                frameRate: 10,
                repeat: -1
            });

            this.anims.create({
                key: 'turn',
                frames: [ { key: 'dude', frame: 4 } ],
                frameRate: 20
            });

            this.anims.create({
                key: 'right',
                frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
                frameRate: 10,
                repeat: -1
            });
            /////// end animation ////////////////

            cursors = this.input.keyboard.createCursorKeys();

            var pointer = this.input.activePointer;
            this.input.on('pointermove', function (pointer) {
                if (pointer.isDown) {
                  angle = Phaser.Math.Angle.BetweenPoints(cannon, pointer);
                  angle=Math.max(angle,-1);
                  angle=Math.min(angle,.5);
                  cannonHead.rotation = angle;
                  Phaser.Geom.Line.SetToAngle(line, cannon.x, cannon.y - 50, angle, 128);
                  gfx.clear().strokeLineShape(line);
                }
            }, this);

            this.clickButton = this.add.text(100, 100, 'FIRE!', { fill: '#0f0' })
              .setInteractive({ useHandCursor: true })
              .on('pointerup',  function () {
                  var bullet = bullets.getFirstDead();
                  if(bullet){
                    bullet.enableBody(true, cannon.x, cannon.y - 50, true, true);
                    bullet.setActive(true);
                    bullet.setVisible(true);
                    bullet.play('right');
                    this.physics.velocityFromRotation(angle, 600, bullet.body.velocity);
                    this.cameras.main.startFollow(bullet, true, 0.05, 0.05);
                  }
              }, this);

          }

          update ()
          {
            /*
            if (cursors.left.isDown)
            {
                player.setVelocityX(-160);

                player.anims.play('left', true);
            }
            else if (cursors.right.isDown)
            {
                player.setVelocityX(160);

                player.anims.play('right', true);
            }
            else
            {
                player.setVelocityX(0);

                player.anims.play('turn');
            }

            if (cursors.up.isDown && player.body.touching.down)
            {
                player.setVelocityY(-330);
            }
            */
          }


          // here we go with some Box2D stuff
          // arguments: x, y coordinates of the center, with and height of the box, in pixels
          // we'll conver pixels to meters inside the method
          createBox(posX, posY, width, height, isDynamic){

              // this is how we create a generic Box2D body
              let box = this.world.createBody();
              if(isDynamic){

                  // Box2D bodies born as static bodies, but we can make them dynamic
                  box.setDynamic();
              }

              // a body can have one or more fixtures. This is how we create a box fixture inside a body
              box.createFixture(planck.Box(width / 2 / this.worldScale, height / 2 / this.worldScale));

              // now we place the body in the world
              box.setPosition(planck.Vec2(posX / this.worldScale, posY / this.worldScale));

              // time to set mass information
              box.setMassData({
                  mass: 1,
                  center: planck.Vec2(),

                  // I have to say I do not know the meaning of this "I", but if you set it to zero, bodies won't rotate
                  I: 1
              });

              // now we create a graphics object representing the body
              var color = new Phaser.Display.Color();
              color.random();
              color.brighten(50).saturate(100);
              let userData = this.add.graphics();
              userData.fillStyle(color.color, 1);
              userData.fillRect(- width / 2, - height / 2, width, height);

              // a body can have anything in its user data, normally it's used to store its sprite
              box.setUserData(userData);
          }

      };
    </script>

</body>
</html>
