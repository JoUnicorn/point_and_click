<!DOCTYPE html>
<html>
<head>
    <script src="js/phaser.min.js"></script>
    <script src="js/planck.js"></script>
</head>
<body>

    <script>

      // to open the server with python
      // python -m http.server 8080
      // http://localhost:8080/

      var gameWidth=1000
      var gameHeight=600
      var worldScaleParam=30;
      var worldGravity=3;
      var zout=2.9;

      let game;
      window.onload = function() {
          let gameConfig = {
              type: Phaser.AUTO,
              width: gameWidth,
              height: gameHeight,
              scene: playGame
          }
          game = new Phaser.Game(gameConfig);
          window.focus();
      }

      class playGame extends Phaser.Scene{
          constructor(){
              super("PlayGame");
          }

          preload ()
          {
            this.load.image('sky', 'assets/images/sky.png');
            this.load.image('ground', 'assets/images/platform.png');
            this.load.image('cannon_head', 'assets/images/cannon_head.png');
            this.load.image('cannon_body', 'assets/images/cannon_body.png');
          }

          create ()
          {
            /////// camera /////
            this.cameras.main.setBounds(0, 0, gameWidth*2, game.config.height);
            var cam = this.cameras.main;
            cam.setZoom(.34); //<1 => zoom out
            /////// end camera /////

            /////// sky ////////////////
            var skyWidth=this.textures.get('sky').source[0].width;
            var skyHeight=this.textures.get('sky').source[0].height;
            this.add.image(0, 0, 'sky').setOrigin(0);
            this.add.image(skyWidth, 0, 'sky').setOrigin(0);
            this.add.image(2*skyWidth, 0, 'sky').setOrigin(0);
            this.add.image(3*skyWidth, 0, 'sky').setOrigin(0);
            this.add.image(0, skyHeight, 'sky').setOrigin(0);
            this.add.image(skyWidth, skyHeight, 'sky').setOrigin(0);
            this.add.image(2*skyWidth, skyHeight, 'sky').setOrigin(0);
            this.add.image(3*skyWidth, skyHeight, 'sky').setOrigin(0);
            this.add.image(0, 2*skyHeight, 'sky').setOrigin(0);
            this.add.image(skyWidth, 2*skyHeight, 'sky').setOrigin(0);
            this.add.image(2*skyWidth, 2*skyHeight, 'sky').setOrigin(0);
            this.add.image(3*skyWidth, 2*skyHeight, 'sky').setOrigin(0);
            /////// end sky ////////////////

            //////// planck.js box2d /////////////
            // Box2D works with meters. We need to convert meters to pixels.
            // let's say 30 pixels = 1 meter.
            this.worldScale = worldScaleParam;

            // world gravity, as a Vec2 object. It's just a x, y vector (x=gravity horizontal, y gravity vertical)
            let gravity = planck.Vec2(0, worldGravity);
            // this is how we create a Box2D world
            this.world = planck.World(gravity);

            //ground
            var groundHeight=this.textures.get('ground').source[0].height;
            var groundWidth=this.textures.get('ground').source[0].width;
            this.createGround(0, zout*game.config.height - groundHeight, groundWidth, groundHeight, false);
            this.createGround(groundWidth, zout*game.config.height - groundHeight, groundWidth, groundHeight, false);
            this.createGround(2*groundWidth, zout*game.config.height - groundHeight, groundWidth, groundHeight, false);
            this.createGround(3*groundWidth, zout*game.config.height - groundHeight, groundWidth, groundHeight, false);
            this.createGround(4*groundWidth, zout*game.config.height - groundHeight, groundWidth, groundHeight, false);
            this.createGround(5*groundWidth, zout*game.config.height - groundHeight, groundWidth, groundHeight, false);
            this.createGround(6*groundWidth, zout*game.config.height - groundHeight, groundWidth, groundHeight, false);
            for (var i = 1; i < 30; i += 1)
            {
              this.createGround(7*groundWidth, zout*game.config.height - i*groundHeight, groundWidth, groundHeight, false);
            }
            this.createGround(1200, zout*game.config.height - 20*groundHeight, groundWidth, groundHeight, false);

            //cannon
            var cannonHead = this.add.image(130, zout*game.config.height - groundHeight-210, 'cannon_head').setDepth(1).setScale(2);
            var cannon = this.add.image(130, zout*game.config.height - groundHeight-110, 'cannon_body').setDepth(1).setScale(2);

            // bar
            var decal=1000
            this.createBar(1300, zout*game.config.height - 20*groundHeight-180, 40, 180, true);
            this.createBar(300+decal, zout*game.config.height- groundHeight-180, 180, 180, true);
            this.createBar(600+decal, zout*game.config.height- groundHeight-180, 40, 180, true);
            this.createBar(800+decal, zout*game.config.height- groundHeight-180, 40, 180, true);
            this.createBar(1000+decal, zout*game.config.height- groundHeight-180, 40, 180, true);
            this.createBar(1200+decal, zout*game.config.height- groundHeight-180, 40, 180, true);
            this.createBar(900+decal, zout*game.config.height- groundHeight-180-80, 700, 30, true);
            this.time.addEvent({
                delay: 1000,
                callbackScope: this,
                callback: function(){
                  this.createBar(700+decal, zout*game.config.height- groundHeight-180-50-100, 50, 180, true);
                  this.createBar(900+decal, zout*game.config.height- groundHeight-180-50-100, 50, 180, true);
                  this.createBar(1100+decal, zout*game.config.height- groundHeight-180-50-100, 50, 180, true);
                  this.createBar(900+decal, zout*game.config.height- groundHeight-180-50-100-110, 500, 30, true);
                },
                loop: false
            });
            this.time.addEvent({
                delay: 3000,
                callbackScope: this,
                callback: function(){
                  this.createBar(800+decal, zout*game.config.height- groundHeight-180-50-300, 50, 180, true);
                  this.createBar(1000+decal, zout*game.config.height- groundHeight-180-50-300, 50, 180, true);
                  this.createBar(900+decal, zout*game.config.height- groundHeight-180-50-300-110, 500, 30, true);
                },
                loop: false
            });
            this.time.addEvent({
                delay: 5000,
                callbackScope: this,
                callback: function(){
                  this.createBar(900+decal, zout*game.config.height- groundHeight-180-50-500, 50, 180, true);
                },
                loop: false
            });

            //cursor
            var pointer = this.input.activePointer;
            var gfx2 = this.add.graphics().setDefaultStyles({ lineStyle: { width: 40, color: 0xffdd00, alpha: 0.5 } });
            var angle = 0;
            var launchVelocity;
            var squareWidth=400
            var squareHeight=500

            this.input.on('pointermove', function (pointer) {
                if (pointer.isDown & zout*pointer.y>zout*game.config.height-squareHeight & zout*pointer.x<squareWidth) {
                  launchVelocity = this.getLaunchVelocity(cannon,pointer);
                  var lastPos = null;

                  gfx2.clear();
                  for (var i = 0; i < 1000; i += 6)
                  {
                      var trajectoryPoint = this.getTrajectoryPoint(cannon.x, cannon.y - 100, launchVelocity.x, launchVelocity.y, i);

                      if (lastPos && i % 12 == 0)
                      {
                          this.line(gfx2,lastPos.x, lastPos.y, trajectoryPoint.x, trajectoryPoint.y);
                      }

                      lastPos = trajectoryPoint;
                  }
                  var trajectoryPoint = this.getTrajectoryPoint(cannon.x, cannon.y - 100, launchVelocity.x, launchVelocity.y, 30);
                  var trajectoryPoint2 = this.getTrajectoryPoint(cannon.x, cannon.y - 100, launchVelocity.x, launchVelocity.y, 1);
                  angle = Phaser.Math.Angle.BetweenPoints(trajectoryPoint2, trajectoryPoint);
                  cannonHead.rotation = angle;

                }
                else{
                  if (!pointer.isDown) return;
                  this.cameras.main.stopFollow();
                  cam.scrollX -= (pointer.x - pointer.prevPosition.x) / cam.zoom;
                }
            }, this);


            /// viseur///
            var graphics = this.add.graphics();

            graphics.fillStyle(0xffffff, .2);
            graphics.fillRect(0, zout*game.config.height-squareHeight, squareWidth, squareHeight);

            // ball
            let balls=[];
            this.clickButton = this.add.text(100, 100, 'FIRE!', { fill: '#0f0' })
              .setFontSize(100)
              .setInteractive({ useHandCursor: true })
              .on('pointerup',  function () {
                  if(launchVelocity!=undefined){
                    balls.push(this.createCircle(cannon.x, cannon.y - 100, 15, true));
                    let veloci = planck.Vec2(launchVelocity.x/(this.worldScale**(1/2)), launchVelocity.y/(this.worldScale**(1/2)));
                    let ud=balls[balls.length-1].getUserData();
                    balls[balls.length-1].setLinearVelocity(veloci);
                    this.cameras.main.startFollow(ud, true, 0.05, 0.05);
                  }
              }, this);
            this.clickButton = this.add.text(500, 100, 'EXPLOSION!', { fill: '#0f0' })
                .setFontSize(100)
                .setInteractive({ useHandCursor: true })
                .on('pointerup',  function () {
                  if(balls.length>0){
                    this.explosion(balls[balls.length-1]);
                    balls.pop();
                  }
                }, this);

            this.clickButton = this.add.text(1500, 100, 'RESET!', { fill: '#0f0' })
                .setFontSize(100)
                .setInteractive({ useHandCursor: true })
                .on('pointerup',  function () {
                    this.scene.restart();
                }, this);

            this.world.on('begin-contact', function(contact) {
              let bodyA=contact.getFixtureA().getBody();
              let bodyB=contact.getFixtureB().getBody();
              if((bodyB.getFixtureList().getFilterGroupIndex()==-1)&(bodyA.getFixtureList().getFilterGroupIndex()==8)){
                balls[balls.length-1].getFixtureList().m_filterGroupIndex=9;
                balls.pop();
              }
            }, this);

          }

          update ()
          {
            this.world.step(1 / worldScaleParam);
            this.world.clearForces();
            for (let b = this.world.getBodyList(); b; b = b.getNext()){
                let bodyPosition = b.getPosition();
                //if(bodyPosition.y>20){ //20 = 600/this.worldScale
                //  console.log(bodyPosition.y);
                //}
                let bodyAngle = b.getAngle();
                let userData = b.getUserData();
                userData.x = bodyPosition.x * this.worldScale;
                userData.y = bodyPosition.y * this.worldScale;
                userData.rotation = bodyAngle;
                if(b.getFixtureList().getFilterGroupIndex()==9){
                  this.explosion(b);
                }
            }


          }


          explosion(ball){
            let posx=ball.getPosition().x* this.worldScale;
            let posy=ball.getPosition().y* this.worldScale;
            ball.getUserData().clear();
            this.world.destroyBody(ball);
            var numRays=32;
            var DEGTORAD=0.0174532925199432957;
            let parts=[];
            for (var i = 0; i < numRays; i++)
            {
              var angle = (i / numRays) * 360 * DEGTORAD;
              var blastPower =30
              let rayDir = planck.Vec2(Math.sin(angle)*blastPower, Math.cos(angle)*blastPower);
              let part=this.createParticulesExpl(posx, posy,5);
              part.setLinearVelocity(rayDir);
              parts.push(part);
            }
            this.cameras.main.stopFollow();
            this.time.addEvent({
                delay: 200,
                callbackScope: this,
                callback: function(){
                  for (var i = 0; i < parts.length; i++)
                  {
                    parts[i].getUserData().clear();
                    this.world.destroyBody(parts[i]);
                  }
                  parts=[];
                },
                loop: false
            });

          }

          createBox(posX, posY, width, height, isDynamic){
              let box = this.world.createBody();
              if(isDynamic){
                  box.setDynamic();
              }
              box.createFixture(planck.Box(width / 2 / this.worldScale, height / 2 / this.worldScale));
              box.setPosition(planck.Vec2(posX / this.worldScale, posY / this.worldScale));
              box.setMassData({
                  mass: 1,
                  center: planck.Vec2(),
                  I: 1
              });
              return box;
          }

          createGround(posX, posY, width, height, isDynamic){
              let box = this.createBox(posX, posY, width, height, isDynamic);
              let userData = this.add.image(0, 0, 'ground');

              box.setUserData(userData);
          }

          createBar(posX, posY, width, height, isDynamic){
              let box = this.createBox(posX, posY, width, height, isDynamic);
              var color = new Phaser.Display.Color();
              color.random();
              color.brighten(50).saturate(100);
              let userData = this.add.graphics();
              userData.fillStyle(color.color, 1);
              userData.fillRect(- width / 2, - height / 2, width, height);
              box.setUserData(userData);
          }

          getTrajectoryPoint(startX, startY, velocityX, velocityY, n) {
              var t = 1 / 60.0; // seconds per time step (at 60fps)

              var stepVelocityX = t *  -velocityX ; // m/s
              var stepVelocityY = t * -velocityY ;

              var stepGravityX = t * t * -this.world.getGravity().x ; // m/s/s
              var stepGravityY = t * t * -this.world.getGravity().y ;

              startX = -startX;
              startY = -startY;

              var tpx = startX + n * stepVelocityX + 0.5 * (n*n+n) * stepGravityX;
              var tpy = startY + n * stepVelocityY + 0.5 * (n*n+n) * stepGravityY;

              tpx = -tpx;
              tpy = -tpy;

              return { x: tpx, y: tpy };

          }

          getLaunchVelocity(cannon,pointer) {

              var dx = (zout*pointer.x - cannon.x)/3;
              var dy = (zout*pointer.y+210 - cannon.y - 100)/3;

              //dx *= 2;//dx=dx*2
              //dy *= 2;

              return { x: dx, y: dy };
          }

          line(gfx2,x1, y1, x2, y2) {
              gfx2.beginPath();
              gfx2.moveTo(x1, y1);
              gfx2.lineTo(x2, y2);
              gfx2.stroke();
          }

          createCircle(posX, posY, width, isDynamic){
              let circle = this.world.createBody({
                                                type: 'dynamic'
                                              });
              circle.createFixture({shape: planck.Circle(width/ this.worldScale),
                density:1.0,
                friction:.2,
                filterGroupIndex:8,
                restitution:.4});
              circle.setPosition(planck.Vec2(posX / this.worldScale, posY / this.worldScale));
              circle.setMassData({
                  mass: 1,
                  center: planck.Vec2(),
                  I: 1
              });
              var color = new Phaser.Display.Color();
              color.random();
              color.brighten(50).saturate(100);
              let userData = this.add.graphics();
              userData.fillStyle(color.color, 1);
              userData.fillCircle(0, 0, width);

              circle.setUserData(userData);

              return circle;

          }

          createParticulesExpl(posX, posY, width){

              let part = this.world.createBody({
                                                type: 'dynamic',
                                                fixedRotation: true,
                                                bullet: true,
                                                linearDamping: 1.5, // arrete le mvt des que le rayon de projection est atteint
                                                //linearVelocity: rayDir,
                                                gravityScale: 0,
                                              });

              let circleShape = planck.Circle(width/ this.worldScale);
              part.createFixture({
                shape: circleShape,
                density: 60,
                friction: 0,
                restitution: .99,
                filterGroupIndex:-1
              });

              part.setPosition(planck.Vec2(posX / this.worldScale, posY / this.worldScale));

              part.setMassData({
                  mass: 1,
                  center: planck.Vec2(),
                  I: 1
              });
              var color = new Phaser.Display.Color();
              color.random();
              color.brighten(50).saturate(100);
              let userData = this.add.graphics();
              userData.fillStyle(color.color, 1);
              userData.fillCircle(0, 0, width);

              part.setUserData(userData);

              return part;

          }

      };
    </script>

</body>
</html>
