<!DOCTYPE html>
<html>
<head>
    <script src="js/phaser.min.js"></script>
    <script src="js/planck.js"></script>
</head>
<body>

    <script>

      // to open the server with python
      // python -m http.server 8080
      // http://localhost:8080/

      var gameWidth=1000
      var gameHeight=600
      var worldScaleParam=30;

      let game;
      window.onload = function() {
          let gameConfig = {
              type: Phaser.AUTO,
              width: gameWidth,
              height: gameHeight,
              scene: playGame
          }
          game = new Phaser.Game(gameConfig);
          window.focus();
      }

      class playGame extends Phaser.Scene{
          constructor(){
              super("PlayGame");
          }

          preload ()
          {
            this.load.image('sky', 'assets/images/sky.png');
            this.load.image('ground', 'assets/images/platform.png');
            this.load.image('cannon_head', 'assets/images/cannon_head.png');
            this.load.image('cannon_body', 'assets/images/cannon_body.png');
          }

          create ()
          {
            /////// camera /////
            this.cameras.main.setBounds(0, 0, gameWidth*2, gameHeight);
            var cam = this.cameras.main;
            cam.setZoom(1); //<1 => zoom out
            /////// end camera /////

            /////// sky ////////////////
            var skyWidth=this.textures.get('sky').source[0].width;
            this.add.image(0, 0, 'sky').setOrigin(0);
            this.add.image(skyWidth, 0, 'sky').setOrigin(0);
            this.add.image(2*skyWidth, 0, 'sky').setOrigin(0);
            /////// end sky ////////////////

            //////// planck.js box2d /////////////
            // Box2D works with meters. We need to convert meters to pixels.
            // let's say 30 pixels = 1 meter.
            this.worldScale = worldScaleParam;

            // world gravity, as a Vec2 object. It's just a x, y vector (x=gravity horizontal, y gravity vertical)
            let gravity = planck.Vec2(0, 3);
            // this is how we create a Box2D world
            this.world = planck.World(gravity);

            //ground
            var groundHeight=this.textures.get('ground').source[0].height;
            var groundWidth=this.textures.get('ground').source[0].width;
            this.createGround(0, game.config.height - groundHeight, groundWidth, groundHeight, false);
            this.createGround(groundWidth, game.config.height - groundHeight, groundWidth, groundHeight, false);
            this.createGround(2*groundWidth, game.config.height - groundHeight, groundWidth, groundHeight, false);

            //cannon
            var cannonHead = this.add.image(100, game.config.height - groundHeight-100, 'cannon_head').setDepth(1);
            var cannon = this.add.image(100, game.config.height - groundHeight-50, 'cannon_body').setDepth(1);

            // bar
            this.createBar(300, -100, 40, 180, true);

            //cursor
            var pointer = this.input.activePointer;
            var gfx2 = this.add.graphics().setDefaultStyles({ lineStyle: { width: 10, color: 0xffdd00, alpha: 0.5 } });
            var angle = 0;
            var launchVelocity;
            var squareWidth=200
            var squareHeight=300

            this.input.on('pointermove', function (pointer) {
                if (pointer.isDown & pointer.y>squareHeight & pointer.x<squareWidth) {
                  launchVelocity = this.getLaunchVelocity(cannon,pointer);
                  var lastPos = null;

                  gfx2.clear();
                  for (var i = 0; i < 1000; i += 6)
                  {
                      var trajectoryPoint = this.getTrajectoryPoint(cannon.x, cannon.y - 50, launchVelocity.x, launchVelocity.y, i);

                      if (lastPos && i % 12 == 0)
                      {
                          this.line(gfx2,lastPos.x, lastPos.y, trajectoryPoint.x, trajectoryPoint.y);
                      }

                      lastPos = trajectoryPoint;
                  }
                  var trajectoryPoint = this.getTrajectoryPoint(cannon.x, cannon.y - 50, launchVelocity.x, launchVelocity.y, 30);
                  var trajectoryPoint2 = this.getTrajectoryPoint(cannon.x, cannon.y - 50, launchVelocity.x, launchVelocity.y, 1);
                  angle = Phaser.Math.Angle.BetweenPoints(trajectoryPoint2, trajectoryPoint);
                  cannonHead.rotation = angle;

                }
            }, this);


            /// viseur///
            var graphics = this.add.graphics();

            graphics.fillStyle(0xffffff, .2);
            graphics.fillRect(0, squareHeight, squareWidth, gameHeight-squareHeight);

            // ball
            this.balls=[];
            this.clickButton = this.add.text(100, 100, 'FIRE!', { fill: '#0f0' })
              .setFontSize(50)
              .setInteractive({ useHandCursor: true })
              .on('pointerup',  function () {
                  this.balls.push(this.createCircle(cannon.x, cannon.y - 50, 15, true));
                  let veloci = planck.Vec2(launchVelocity.x/this.worldScale, launchVelocity.y/this.worldScale);
                  let ud=this.balls[this.balls.length-1].getUserData();
                  this.balls[this.balls.length-1].setLinearVelocity(veloci);
                  this.balls[this.balls.length-1].setGravityScale(1/this.worldScale);
                  this.cameras.main.startFollow(ud, true, 0.05, 0.05);
              }, this);


          }

          update ()
          {
            this.world.step(1 / worldScaleParam);
            this.world.clearForces();
            for (let b = this.world.getBodyList(); b; b = b.getNext()){
                let bodyPosition = b.getPosition();
                let bodyAngle = b.getAngle();
                let userData = b.getUserData();
                userData.x = bodyPosition.x * this.worldScale;
                userData.y = bodyPosition.y * this.worldScale;
                userData.rotation = bodyAngle;
            }


          }

          createBox(posX, posY, width, height, isDynamic){
              let box = this.world.createBody();
              if(isDynamic){
                  box.setDynamic();
              }
              box.createFixture(planck.Box(width / 2 / this.worldScale, height / 2 / this.worldScale));
              box.setPosition(planck.Vec2(posX / this.worldScale, posY / this.worldScale));
              box.setMassData({
                  mass: 1,
                  center: planck.Vec2(),
                  I: 1
              });
              return box;
            }

          createGround(posX, posY, width, height, isDynamic){
              let box = this.createBox(posX, posY, width, height, isDynamic);
              let userData = this.add.image(0, 0, 'ground');

              box.setUserData(userData);
          }

          createBar(posX, posY, width, height, isDynamic){
              let box = this.createBox(posX, posY, width, height, isDynamic);
              var color = new Phaser.Display.Color();
              color.random();
              color.brighten(50).saturate(100);
              let userData = this.add.graphics();
              userData.fillStyle(color.color, 1);
              userData.fillRect(- width / 2, - height / 2, width, height);
              box.setUserData(userData);
          }

          getTrajectoryPoint(startX, startY, velocityX, velocityY, n) {
              var t = 1 / 60.0; // seconds per time step (at 60fps)

              var stepVelocityX = t *  -velocityX ; // m/s
              var stepVelocityY = t * -velocityY ;

              var stepGravityX = t * t * -this.world.getGravity().x ; // m/s/s
              var stepGravityY = t * t * -this.world.getGravity().y ;

              startX = -startX;
              startY = -startY;

              var tpx = startX + n * stepVelocityX + 0.5 * (n*n+n) * stepGravityX;
              var tpy = startY + n * stepVelocityY + 0.5 * (n*n+n) * stepGravityY;

              tpx = -tpx;
              tpy = -tpy;

              return { x: tpx, y: tpy };

          }

          getLaunchVelocity(cannon,pointer) {

              var dx = pointer.x+50 - cannon.x;
              var dy = pointer.y+50 - cannon.y - 50;

              dx *= 2;//dx=dx*2
              dy *= 2;

              return { x: dx, y: dy };
          }

          line(gfx2,x1, y1, x2, y2) {
              gfx2.beginPath();
              gfx2.moveTo(x1, y1);
              gfx2.lineTo(x2, y2);
              gfx2.stroke();
          }

          createCircle(posX, posY, width, isDynamic){
              let circle = this.world.createBody({
                                                type: 'dynamic',
                                                //gravityScale: 0,
                                              });
              circle.createFixture(planck.Circle(width/ this.worldScale));
              circle.setPosition(planck.Vec2(posX / this.worldScale, posY / this.worldScale));
              circle.setMassData({
                  mass: 1,
                  center: planck.Vec2(),
                  I: 1
              });
              var color = new Phaser.Display.Color();
              color.random();
              color.brighten(50).saturate(100);
              let userData = this.add.graphics();
              userData.fillStyle(color.color, 1);
              userData.fillCircle(0, 0, width);

              circle.setUserData(userData);

              return circle;

          }

      };
    </script>

</body>
</html>
